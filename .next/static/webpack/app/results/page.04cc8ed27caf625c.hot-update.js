"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/results/page",{

/***/ "(app-pages-browser)/./src/lib/arxiv.ts":
/*!**************************!*\
  !*** ./src/lib/arxiv.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   batchIndexArxivPapers: function() { return /* binding */ batchIndexArxivPapers; },\n/* harmony export */   fetchPaperContent: function() { return /* binding */ fetchPaperContent; },\n/* harmony export */   searchArxiv: function() { return /* binding */ searchArxiv; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var xml2js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xml2js */ \"(app-pages-browser)/./node_modules/xml2js/lib/xml2js.js\");\n/* harmony import */ var xml2js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(xml2js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cache */ \"(app-pages-browser)/./src/lib/cache.ts\");\n/* harmony import */ var _pinecone__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pinecone */ \"(app-pages-browser)/./src/lib/pinecone.ts\");\n\n\n\n\nconst ARXIV_API_URL = \"http://export.arxiv.org/api/query\";\nconst CACHE_TTL = 3600; // 1 hour\nconst MAX_RETRIES = 5;\nconst BASE_DELAY = 1000; // 1 second base delay\nasync function delay(ms) {\n    return new Promise((resolve)=>setTimeout(resolve, ms));\n}\nasync function retryWithBackoff(operation) {\n    let retries = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : MAX_RETRIES, baseDelay = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : BASE_DELAY, factor = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 2;\n    let lastError;\n    for(let i = 0; i < retries; i++){\n        try {\n            // Add a small random delay before each request to prevent thundering herd\n            await delay(Math.random() * 1000);\n            return await operation();\n        } catch (error) {\n            var _error_response, _error_response1;\n            lastError = error;\n            // If this is a rate limit or connection error, wait and retry\n            if (error.code === \"ECONNRESET\" || error.code === \"ETIMEDOUT\" || ((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 429 || ((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.status) >= 500) {\n                const waitTime = baseDelay * Math.pow(factor, i) * (1 + Math.random() * 0.1);\n                console.warn(\"Request failed (attempt \".concat(i + 1, \"/\").concat(retries, \"). Waiting \").concat(Math.round(waitTime), \"ms before retry...\"));\n                await delay(waitTime);\n                continue;\n            }\n            // For other errors, throw immediately\n            throw error;\n        }\n    }\n    throw lastError;\n}\nasync function searchArxiv(query) {\n    let maxResults = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100, start = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, sortBy = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"submittedDate\", sortOrder = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : \"descending\";\n    // Check cache first\n    const cacheKey = \"arxiv_search:\".concat(query, \":\").concat(maxResults, \":\").concat(start, \":\").concat(sortBy, \":\").concat(sortOrder);\n    const cachedResult = (0,_cache__WEBPACK_IMPORTED_MODULE_1__.getCachedData)(cacheKey);\n    if (cachedResult) {\n        return cachedResult;\n    }\n    try {\n        // Use retryWithBackoff for the API call\n        const response = await retryWithBackoff(()=>axios__WEBPACK_IMPORTED_MODULE_3__[\"default\"].get(ARXIV_API_URL, {\n                params: {\n                    search_query: query,\n                    start,\n                    max_results: maxResults,\n                    sortBy,\n                    sortOrder\n                },\n                timeout: 30000,\n                headers: {\n                    \"User-Agent\": \"Perplexity Research Assistant/1.0\"\n                }\n            }));\n        const result = await (0,xml2js__WEBPACK_IMPORTED_MODULE_0__.parseStringPromise)(response.data);\n        const entries = result.feed.entry || [];\n        const papers = entries.map((entry)=>{\n            var _entry_arxivdoi, _entry_arxivjournal_ref;\n            const categories = Array.isArray(entry.category) ? entry.category.map((cat)=>cat.$.term) : [];\n            const id = entry.id[0].split(\"/abs/\")[1];\n            const version = parseInt(id.split(\"v\")[1]) || 1;\n            return {\n                id,\n                title: entry.title[0].replace(/\\s+/g, \" \").trim(),\n                summary: entry.summary[0].replace(/\\s+/g, \" \").trim(),\n                authors: entry.author.map((author)=>author.name[0]),\n                categories,\n                published: entry.published[0],\n                updated: entry.updated[0],\n                doi: (_entry_arxivdoi = entry[\"arxiv:doi\"]) === null || _entry_arxivdoi === void 0 ? void 0 : _entry_arxivdoi[0],\n                journal_ref: (_entry_arxivjournal_ref = entry[\"arxiv:journal_ref\"]) === null || _entry_arxivjournal_ref === void 0 ? void 0 : _entry_arxivjournal_ref[0],\n                pdf_url: \"https://arxiv.org/pdf/\".concat(id, \".pdf\"),\n                version\n            };\n        });\n        // Cache the results\n        (0,_cache__WEBPACK_IMPORTED_MODULE_1__.setCachedData)(cacheKey, papers, CACHE_TTL);\n        return papers;\n    } catch (error) {\n        console.error(\"Error fetching from arXiv:\", error);\n        throw error;\n    }\n}\nasync function fetchPaperContent(paperId) {\n    try {\n        var _result_feed_entry;\n        // Use retryWithBackoff for the API call\n        const response = await retryWithBackoff(()=>axios__WEBPACK_IMPORTED_MODULE_3__[\"default\"].get(\"\".concat(ARXIV_API_URL, \"?id_list=\").concat(paperId), {\n                timeout: 30000,\n                headers: {\n                    \"User-Agent\": \"Perplexity Research Assistant/1.0\"\n                }\n            }));\n        const result = await (0,xml2js__WEBPACK_IMPORTED_MODULE_0__.parseStringPromise)(response.data);\n        const entry = (_result_feed_entry = result.feed.entry) === null || _result_feed_entry === void 0 ? void 0 : _result_feed_entry[0];\n        if (!entry || !entry.summary) {\n            throw new Error(\"No abstract available\");\n        }\n        // Return the abstract\n        return entry.summary[0].trim();\n    } catch (error) {\n        console.error(\"Error fetching paper content:\", error);\n        return \"\"; // Return empty string if fetch fails\n    }\n}\n// Implement batch processing for vector store operations\nasync function batchIndexArxivPapers(papers) {\n    let batchSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n    for(let i = 0; i < papers.length; i += batchSize){\n        const batch = papers.slice(i, i + batchSize);\n        await Promise.all(batch.map((paper)=>(0,_pinecone__WEBPACK_IMPORTED_MODULE_2__.indexArxivPaper)(\"Title: \".concat(paper.title, \"\\n\\nAbstract: \").concat(paper.summary, \"\\n\\nAuthors: \").concat(paper.authors.join(\", \")), {\n                paperId: paper.id,\n                title: paper.title,\n                authors: paper.authors,\n                categories: paper.categories,\n                published: paper.published\n            })));\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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InNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2FyeGl2LnRzPzZkZWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCB7IHBhcnNlU3RyaW5nUHJvbWlzZSB9IGZyb20gJ3htbDJqcyc7XG5pbXBvcnQgeyBnZXRDYWNoZWREYXRhLCBzZXRDYWNoZWREYXRhIH0gZnJvbSAnLi9jYWNoZSc7XG5pbXBvcnQgeyBpbmRleEFyeGl2UGFwZXIsIHR5cGUgQXJ4aXZNZXRhZGF0YSB9IGZyb20gJy4vcGluZWNvbmUnO1xuXG5jb25zdCBBUlhJVl9BUElfVVJMID0gJ2h0dHA6Ly9leHBvcnQuYXJ4aXYub3JnL2FwaS9xdWVyeSc7XG5jb25zdCBDQUNIRV9UVEwgPSAzNjAwOyAvLyAxIGhvdXJcbmNvbnN0IE1BWF9SRVRSSUVTID0gNTtcbmNvbnN0IEJBU0VfREVMQVkgPSAxMDAwOyAvLyAxIHNlY29uZCBiYXNlIGRlbGF5XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXJ4aXZQYXBlciB7XG4gIGlkOiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIHN1bW1hcnk6IHN0cmluZztcbiAgYXV0aG9yczogc3RyaW5nW107XG4gIGNhdGVnb3JpZXM6IHN0cmluZ1tdO1xuICBwdWJsaXNoZWQ6IHN0cmluZztcbiAgdXBkYXRlZDogc3RyaW5nO1xuICBkb2k/OiBzdHJpbmc7XG4gIGpvdXJuYWxfcmVmPzogc3RyaW5nO1xuICBwZGZfdXJsPzogc3RyaW5nO1xuICB2ZXJzaW9uPzogbnVtYmVyO1xufVxuXG5hc3luYyBmdW5jdGlvbiBkZWxheShtczogbnVtYmVyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmV0cnlXaXRoQmFja29mZjxUPihcbiAgb3BlcmF0aW9uOiAoKSA9PiBQcm9taXNlPFQ+LFxuICByZXRyaWVzID0gTUFYX1JFVFJJRVMsXG4gIGJhc2VEZWxheSA9IEJBU0VfREVMQVksXG4gIGZhY3RvciA9IDJcbik6IFByb21pc2U8VD4ge1xuICBsZXQgbGFzdEVycm9yOiBhbnk7XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJldHJpZXM7IGkrKykge1xuICAgIHRyeSB7XG4gICAgICAvLyBBZGQgYSBzbWFsbCByYW5kb20gZGVsYXkgYmVmb3JlIGVhY2ggcmVxdWVzdCB0byBwcmV2ZW50IHRodW5kZXJpbmcgaGVyZFxuICAgICAgYXdhaXQgZGVsYXkoTWF0aC5yYW5kb20oKSAqIDEwMDApO1xuICAgICAgcmV0dXJuIGF3YWl0IG9wZXJhdGlvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGxhc3RFcnJvciA9IGVycm9yO1xuICAgICAgXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgcmF0ZSBsaW1pdCBvciBjb25uZWN0aW9uIGVycm9yLCB3YWl0IGFuZCByZXRyeVxuICAgICAgaWYgKFxuICAgICAgICBlcnJvci5jb2RlID09PSAnRUNPTk5SRVNFVCcgfHxcbiAgICAgICAgZXJyb3IuY29kZSA9PT0gJ0VUSU1FRE9VVCcgfHxcbiAgICAgICAgZXJyb3IucmVzcG9uc2U/LnN0YXR1cyA9PT0gNDI5IHx8XG4gICAgICAgIGVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPj0gNTAwXG4gICAgICApIHtcbiAgICAgICAgY29uc3Qgd2FpdFRpbWUgPSBiYXNlRGVsYXkgKiBNYXRoLnBvdyhmYWN0b3IsIGkpICogKDEgKyBNYXRoLnJhbmRvbSgpICogMC4xKTtcbiAgICAgICAgY29uc29sZS53YXJuKGBSZXF1ZXN0IGZhaWxlZCAoYXR0ZW1wdCAke2kgKyAxfS8ke3JldHJpZXN9KS4gV2FpdGluZyAke01hdGgucm91bmQod2FpdFRpbWUpfW1zIGJlZm9yZSByZXRyeS4uLmApO1xuICAgICAgICBhd2FpdCBkZWxheSh3YWl0VGltZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBGb3Igb3RoZXIgZXJyb3JzLCB0aHJvdyBpbW1lZGlhdGVseVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICB0aHJvdyBsYXN0RXJyb3I7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZWFyY2hBcnhpdihcbiAgcXVlcnk6IHN0cmluZyxcbiAgbWF4UmVzdWx0czogbnVtYmVyID0gMTAwLFxuICBzdGFydDogbnVtYmVyID0gMCxcbiAgc29ydEJ5OiAnc3VibWl0dGVkRGF0ZScgfCAncmVsZXZhbmNlJyB8ICdsYXN0VXBkYXRlZERhdGUnID0gJ3N1Ym1pdHRlZERhdGUnLFxuICBzb3J0T3JkZXI6ICdhc2NlbmRpbmcnIHwgJ2Rlc2NlbmRpbmcnID0gJ2Rlc2NlbmRpbmcnXG4pOiBQcm9taXNlPEFyeGl2UGFwZXJbXT4ge1xuICAvLyBDaGVjayBjYWNoZSBmaXJzdFxuICBjb25zdCBjYWNoZUtleSA9IGBhcnhpdl9zZWFyY2g6JHtxdWVyeX06JHttYXhSZXN1bHRzfToke3N0YXJ0fToke3NvcnRCeX06JHtzb3J0T3JkZXJ9YDtcbiAgY29uc3QgY2FjaGVkUmVzdWx0ID0gZ2V0Q2FjaGVkRGF0YTxBcnhpdlBhcGVyW10+KGNhY2hlS2V5KTtcbiAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFVzZSByZXRyeVdpdGhCYWNrb2ZmIGZvciB0aGUgQVBJIGNhbGxcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJldHJ5V2l0aEJhY2tvZmYoKCkgPT4gXG4gICAgICBheGlvcy5nZXQoQVJYSVZfQVBJX1VSTCwge1xuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBzZWFyY2hfcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIG1heF9yZXN1bHRzOiBtYXhSZXN1bHRzLFxuICAgICAgICAgIHNvcnRCeSxcbiAgICAgICAgICBzb3J0T3JkZXIsXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVvdXQ6IDMwMDAwLCAvLyAzMCBzZWNvbmQgdGltZW91dFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ1VzZXItQWdlbnQnOiAnUGVycGxleGl0eSBSZXNlYXJjaCBBc3Npc3RhbnQvMS4wJ1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwYXJzZVN0cmluZ1Byb21pc2UocmVzcG9uc2UuZGF0YSk7XG4gICAgY29uc3QgZW50cmllcyA9IHJlc3VsdC5mZWVkLmVudHJ5IHx8IFtdO1xuXG4gICAgY29uc3QgcGFwZXJzID0gZW50cmllcy5tYXAoKGVudHJ5OiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBBcnJheS5pc0FycmF5KGVudHJ5LmNhdGVnb3J5KVxuICAgICAgICA/IGVudHJ5LmNhdGVnb3J5Lm1hcCgoY2F0OiBhbnkpID0+IGNhdC4kLnRlcm0pXG4gICAgICAgIDogW107XG5cbiAgICAgIGNvbnN0IGlkID0gZW50cnkuaWRbMF0uc3BsaXQoJy9hYnMvJylbMV07XG4gICAgICBjb25zdCB2ZXJzaW9uID0gcGFyc2VJbnQoaWQuc3BsaXQoJ3YnKVsxXSkgfHwgMTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQsXG4gICAgICAgIHRpdGxlOiBlbnRyeS50aXRsZVswXS5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpLFxuICAgICAgICBzdW1tYXJ5OiBlbnRyeS5zdW1tYXJ5WzBdLnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCksXG4gICAgICAgIGF1dGhvcnM6IGVudHJ5LmF1dGhvci5tYXAoKGF1dGhvcjogYW55KSA9PiBhdXRob3IubmFtZVswXSksXG4gICAgICAgIGNhdGVnb3JpZXMsXG4gICAgICAgIHB1Ymxpc2hlZDogZW50cnkucHVibGlzaGVkWzBdLFxuICAgICAgICB1cGRhdGVkOiBlbnRyeS51cGRhdGVkWzBdLFxuICAgICAgICBkb2k6IGVudHJ5Wydhcnhpdjpkb2knXT8uWzBdLFxuICAgICAgICBqb3VybmFsX3JlZjogZW50cnlbJ2FyeGl2OmpvdXJuYWxfcmVmJ10/LlswXSxcbiAgICAgICAgcGRmX3VybDogYGh0dHBzOi8vYXJ4aXYub3JnL3BkZi8ke2lkfS5wZGZgLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIENhY2hlIHRoZSByZXN1bHRzXG4gICAgc2V0Q2FjaGVkRGF0YShjYWNoZUtleSwgcGFwZXJzLCBDQUNIRV9UVEwpO1xuICAgIHJldHVybiBwYXBlcnM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgZnJvbSBhclhpdjonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoUGFwZXJDb250ZW50KHBhcGVySWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIHJldHJ5V2l0aEJhY2tvZmYgZm9yIHRoZSBBUEkgY2FsbFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmV0cnlXaXRoQmFja29mZigoKSA9PlxuICAgICAgYXhpb3MuZ2V0KGAke0FSWElWX0FQSV9VUkx9P2lkX2xpc3Q9JHtwYXBlcklkfWAsIHtcbiAgICAgICAgdGltZW91dDogMzAwMDAsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnVXNlci1BZ2VudCc6ICdQZXJwbGV4aXR5IFJlc2VhcmNoIEFzc2lzdGFudC8xLjAnXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgICBcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwYXJzZVN0cmluZ1Byb21pc2UocmVzcG9uc2UuZGF0YSk7XG4gICAgY29uc3QgZW50cnkgPSByZXN1bHQuZmVlZC5lbnRyeT8uWzBdO1xuICAgIFxuICAgIGlmICghZW50cnkgfHwgIWVudHJ5LnN1bW1hcnkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWJzdHJhY3QgYXZhaWxhYmxlJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFJldHVybiB0aGUgYWJzdHJhY3RcbiAgICByZXR1cm4gZW50cnkuc3VtbWFyeVswXS50cmltKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcGFwZXIgY29udGVudDonLCBlcnJvcik7XG4gICAgcmV0dXJuICcnOyAvLyBSZXR1cm4gZW1wdHkgc3RyaW5nIGlmIGZldGNoIGZhaWxzXG4gIH1cbn1cblxuLy8gSW1wbGVtZW50IGJhdGNoIHByb2Nlc3NpbmcgZm9yIHZlY3RvciBzdG9yZSBvcGVyYXRpb25zXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYmF0Y2hJbmRleEFyeGl2UGFwZXJzKHBhcGVyczogQXJ4aXZQYXBlcltdLCBiYXRjaFNpemU6IG51bWJlciA9IDEwKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFwZXJzLmxlbmd0aDsgaSArPSBiYXRjaFNpemUpIHtcbiAgICBjb25zdCBiYXRjaCA9IHBhcGVycy5zbGljZShpLCBpICsgYmF0Y2hTaXplKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChiYXRjaC5tYXAocGFwZXIgPT4gaW5kZXhBcnhpdlBhcGVyKFxuICAgICAgYFRpdGxlOiAke3BhcGVyLnRpdGxlfVxcblxcbkFic3RyYWN0OiAke3BhcGVyLnN1bW1hcnl9XFxuXFxuQXV0aG9yczogJHtwYXBlci5hdXRob3JzLmpvaW4oJywgJyl9YCxcbiAgICAgIHtcbiAgICAgICAgcGFwZXJJZDogcGFwZXIuaWQsXG4gICAgICAgIHRpdGxlOiBwYXBlci50aXRsZSxcbiAgICAgICAgYXV0aG9yczogcGFwZXIuYXV0aG9ycyxcbiAgICAgICAgY2F0ZWdvcmllczogcGFwZXIuY2F0ZWdvcmllcyxcbiAgICAgICAgcHVibGlzaGVkOiBwYXBlci5wdWJsaXNoZWQsXG4gICAgICB9IGFzIEFyeGl2TWV0YWRhdGEpXG4gICAgKSk7XG4gIH1cbn0iXSwibmFtZXMiOlsiYXhpb3MiLCJwYXJzZVN0cmluZ1Byb21pc2UiLCJnZXRDYWNoZWREYXRhIiwic2V0Q2FjaGVkRGF0YSIsImluZGV4QXJ4aXZQYXBlciIsIkFSWElWX0FQSV9VUkwiLCJDQUNIRV9UVEwiLCJNQVhfUkVUUklFUyIsIkJBU0VfREVMQVkiLCJkZWxheSIsIm1zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwicmV0cnlXaXRoQmFja29mZiIsIm9wZXJhdGlvbiIsInJldHJpZXMiLCJiYXNlRGVsYXkiLCJmYWN0b3IiLCJsYXN0RXJyb3IiLCJpIiwiTWF0aCIsInJhbmRvbSIsImVycm9yIiwiY29kZSIsInJlc3BvbnNlIiwic3RhdHVzIiwid2FpdFRpbWUiLCJwb3ciLCJjb25zb2xlIiwid2FybiIsInJvdW5kIiwic2VhcmNoQXJ4aXYiLCJxdWVyeSIsIm1heFJlc3VsdHMiLCJzdGFydCIsInNvcnRCeSIsInNvcnRPcmRlciIsImNhY2hlS2V5IiwiY2FjaGVkUmVzdWx0IiwiZ2V0IiwicGFyYW1zIiwic2VhcmNoX3F1ZXJ5IiwibWF4X3Jlc3VsdHMiLCJ0aW1lb3V0IiwiaGVhZGVycyIsInJlc3VsdCIsImRhdGEiLCJlbnRyaWVzIiwiZmVlZCIsImVudHJ5IiwicGFwZXJzIiwibWFwIiwiY2F0ZWdvcmllcyIsIkFycmF5IiwiaXNBcnJheSIsImNhdGVnb3J5IiwiY2F0IiwiJCIsInRlcm0iLCJpZCIsInNwbGl0IiwidmVyc2lvbiIsInBhcnNlSW50IiwidGl0bGUiLCJyZXBsYWNlIiwidHJpbSIsInN1bW1hcnkiLCJhdXRob3JzIiwiYXV0aG9yIiwibmFtZSIsInB1Ymxpc2hlZCIsInVwZGF0ZWQiLCJkb2kiLCJqb3VybmFsX3JlZiIsInBkZl91cmwiLCJmZXRjaFBhcGVyQ29udGVudCIsInBhcGVySWQiLCJFcnJvciIsImJhdGNoSW5kZXhBcnhpdlBhcGVycyIsImJhdGNoU2l6ZSIsImxlbmd0aCIsImJhdGNoIiwic2xpY2UiLCJhbGwiLCJwYXBlciIsImpvaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/arxiv.ts\n"));

/***/ })

});